# 문제
# 우리는 어떤 장난감을 여러 가지 부품으로 조립하여 만들려고 한다.
# 이 장난감을 만드는데는 기본 부품과 그 기본 부품으로 조립하여 만든 중간 부품이 사용된다.
# 기본 부품은 다른 부품을 사용하여 조립될 수 없는 부품이다. 중간 부품은 또 다른 중간 부품이나 기본 부품을 이용하여 만들어지는 부품이다.

# 예를 들어보자. 기본 부품으로서 1, 2, 3, 4가 있다.
# 중간 부품 5는 2개의 기본 부품 1과 2개의 기본 부품 2로 만들어진다.
# 중간 부품 6은 2개의 중간 부품 5, 3개의 기본 부품 3과 4개의 기본 부품 4로 만들어진다.
# 장난감 완제품 7은 2개의 중간 부품 5, 3개의 중간 부품 6과 5개의 기본 부품 4로 만들어진다.
# 이런 경우에 장난감 완제품 7을 만드는데 필요한 기본 부품의 개수는 1번 16개, 2번 16개, 3번 9개, 4번 17개이다.

# 이와 같이 어떤 장난감 완제품과 그에 필요한 부품들 사이의 관계가 주어져 있을 때
# 하나의 장난감 완제품을 조립하기 위하여 필요한 기본 부품의 종류별 개수를 계산하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에는 자연수 N(3 ≤ N ≤ 100)이 주어지는데, 1부터 N-1까지는 기본 부품이나 중간 부품의 번호를 나타내고,
# N은 완제품의 번호를 나타낸다. 그리고 그 다음 줄에는 자연수 M(3 ≤ M ≤ 100)이 주어지고,
# 그 다음 M개의 줄에는 어떤 부품을 완성하는데 필요한 부품들 간의 관계가 3개의 자연수 X, Y, K로 주어진다.
# 이 뜻은 "중간 부품이나 완제품 X를 만드는데 중간 부품 혹은 기본 부품 Y가 K개 필요하다"는 뜻이다.
# 두 중간 부품이 서로를 필요로 하는 경우가 없다.

# 출력
# 하나의 완제품을 조립하는데 필요한 기본 부품의 수를 한 줄에 하나씩 출력하되(중간 부품은 출력하지 않음),
# 반드시 기본 부품의 번호가 작은 것부터 큰 순서가 되도록 한다. 각 줄에는 기본 부품의 번호와 소요 개수를 출력한다.

from collections import deque
# 노드의 개수와 간선의 개수 입력
N = int(input())
M = int(input())
# 모든 노드의 대한 진압차수는 0으로 초기화
indegree = [0] * (N + 1)
# 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트 초기화
graph = [[] for i in range(N + 1)]
graph2 = [[] for i in range(N + 1)]

# 방향 그래프의 모든 간선 정보를 입력 받기
for _ in range(M) :
    X, Y, K = map(int, input().split())
    graph[Y].append(X) # 정점 Y에서 K로 이동 가능
    graph2[X].append(Y) # 정점 Y에서 K로 이동 가능
    # 진입 차수를 1 증가
    indegree[Y] += K
print(graph2)
# 위상 정렬 함수
def topology_sort():
    result = [[] for i in range(N + 1)] # 알고리즘 수행 결과를 담을 리스트
    result[N] = [1]
    q = deque() # 큐 기능을 위한 deque 라이브러리 사용
    # 처음 시작할 때는 진입 차수가 0인 노드를 큐에 삽입
    for i in range(1, N + 1) :
        if indegree[i] == 0 :
            q.append(i)
    # 큐가 빌 때까지 반복
    while q :
        now = q.popleft()
        print('now값 ',now)
        # 해당 원소와 연결된 노드들의 진입차수에서 1 빼기
        for i in graph2[now] :
            result[i] += indegree[i] * result[now]
            print(result)
            q.append(i)

    # 위상 정렬을 수행한 결과 출력
    for i in range(1, 5) :
        print(i, result[i])

topology_sort()